# Играем в paper.io

В этом репозитории вы найдете решение для игры в paper.io,
занявшее 3-е место в контесте https://github.com/MailRuChamps/miniaicups/tree/master/paperio

## Начало

Контест начался с отладочного этапа, организаторы выкатили
репозиторий с local-runner-ом на питоне. По сути, все время до
официального начала многие участники (и я в том числе) занимались 
тем, что пытались разобраться в коде local-runner-а, найти в нем
баги и странности. Найденные важные проблемы:

- Неправильный учет времени - решениям участников одновременно
отправлялось состояние, а затем они последовательно опрашивались
с заявленным таймаутом в 5 секунд. В результате второе решение
начинало думать сразу, а его время начинало бежать только после
ответа первого.

- Алгоритм заливки - самое странное и противоречивое место во всем 
коде. Плохо в нем не столько то, что он имеет огромную вычислительную
сложность, а то, что его нельзя описать простыми словами.

При этом поведение алгоритма заливки практически тождественно 
простому алгоритму,
который участники прозвали "bfs от краев карты". Все очень просто:

- Добавляем в очередь все клетки границы, кроме клеток шлейфа и клеток
территории игрока.

- После этого - обычный bfs - выбираем очередную клетку
из очереди и добавляем в очередь ее соседей, так же кроме клеток
шлейфа и территории.

- Все клетки, который мы таким образом покрасили -
это те, которые игрок не залил, остальные, следовательно, залил.

Убедить организаторов взять этот алгоритм не удалось, но многие
участники взяли его себе в симулятор. Либо взяли какую-то его
оптимизированную разновидность.

Я обычно пишу симулятор, тождественный тому, который дают организаторы,
но на C#, так сделал и в этот раз.
Это часто помогает мне разобраться в нюансах игры, найти ошибки, и получить
какую-то исходную интуицию по поводу того, как можно решать поставленную
задачу. В реальных моих стратегиях он используется редко, там обычно
приходится писать что-то оптимизированное, а в данном контесте - еще и 
приближенное.

Код портированного симулятора можно посмотреть в проекте
[BrutalTester](https://github.com/spaceorc/aicup2019-paperio/tree/master/BrutalTester).
Название проекта говорит о том, что я хотел использовать его, чтобы гонять
много игр между разными стратегиями локально или на кластере, но в этот
раз это не пригодилось.

## Базовая идея

За время старта мне в голову долго не приходило ничего умного. По большому счету,
все вертелось вокруг двух мыслей. Первая - сделать минимакс, убирая из рассмотрения 
далеких игроков. Вторая - выбирать каким-то образом случайные пути,
симулировать, выбирать по какой-то оценке сучшее решение.

С первой идеей все более менее понятно, вторая, хоть и выглядит проще,
оставляет за кадром много вопросов. Как выбирать эти пути? Как учитывать
соперников? Например, можно считать, что соперники будут стараться мешать,
стараться пересечь наш шлейф. Но что это значит? Они будут бежать к ближайшей
точке предполагаемого шлейфа?

Вот тут сработала интуиция. Что, если мы будем выбирать безопасные пути, такие, чтобы
соперники не могли помешать их построить? Как же построить такой путь? Довольно
просто, оказывается.

Что значит, что соперник помешал нам построить путь? Предположим, нам
надо 10 тиков времени чтобы добежать до своей территории и закончить путь.
10 тиков - это много или мало? Путь - это набор клеток шлейфа. До каждой такой клетки
соперник может добежать за какое-то время. Значит, если есть клетки шлейфа, до которых
он может добежать за 9 тиков и менее, то такой путь нам не подходит.


Итак, верхнеуровневый алгоритм:
1. Строим карту времени - важная часть всей этой логики - знание, за какое 
время соперник добежит до какой-то клетки.
2. Строим случайный безопасный путь с использованием этой карты.
3. Симулируем движение вдоль него. Враги, по построению, не могут нам 
помешать, значит, они просто бегут домой на свою территорию по кратчайшему
 пути.
4. Оцениваем результат какой-то оценочной функцией, выбираем лучшее решение.
5. Продолжаем с пункта 2, пока еще есть время.

Здесь есть несколько кирпичиков, рассмотрим их всех по порядку.

## Мир

Для начала, в каком виде мы будем представлять себе мир. Мир - это карта 
31 на 31 клеточку. На ней расположено от одного до 6 ботов. Каждый бот
может либо находиться в какой-то клеточке, либо находиться на пути из одной
клеточки в соседнюю. Поэтому позиция бота представляется тройкой:

- `pos` - позиция, где бот стоит, если он стоит в клеточке, либо позиция,
из которой он ушел, если он в пути из одной клеточки в другую.
- `arrivePos` - равна `pos` если бот стоит в клеточке, либо позиция, куда он
скоро прибудет, если он находится в пути.
- `arriveTime` - время прибытия в `arrivePos`, 0 если бот стоит в клеточке

Кроме этих свойств у бота будут еще:
- `speed` - скорость бота.
- `shiftTime` - обратная величина к скорости бота - время, за которое
бот проходит целую клеточку. Равна 6 при скорости 5, равна 5 при скорости 6,
равна 10 при скорости 3.
- `nitroLeft` - сколько осталось дейтсвовать нитро.
- `slowLeft` - сколько осталось действовать замедлялке.

## Карта времени

Итак, нам надо знать, в какой момент времени до куда может добраться каждый
игрок.

Первая, наивная идея - посчитаем манхеттенское расстояние между `arrivePos`
бота, умножим его на скорость бота, добавим `arriveTime`.

Код (точнее, конечно, псевдокод, здесь и далее):
```c#
var times = new Dictionary<V, int>();
for (var x = 0; x < 31; ++x)
{
    for (var y = 0; y < 31; ++y)
    {
        var v = new V(x, y);
        var dist = (v - bot.arrivePos).ManhattanLength();
        times[v] = bot.arriveTime + dist * bot.shiftTime;
    }
}
```

Что не учитывает этот подход? Во первых, скорость бота может меняться,
он может подбирать бонусы, его бонусы могут использоваться и исчезать.
Во вторых, бот не может проходить через свой шлейф, потому мы можем
переоценивать его способность нам помешать и наш бот будет черезчур
пугливым. В третьих, не учтено, что бот не может повернуть на 180 градусов
и пойти назад. 

Улучшаем идею - сначала разберемся с собственным шлейфом. Это просто,
достаточно пустить волну от `arrivePos` бота, запретив ему заходить
на свой шлейф.

```c#
var times = new Dictionary<V, int>();
var queue = new Queue<V>();
times.Add(bot.arrivePos, bot.arriveTime);
queue.Enqueue(bot.arrivePos);
while (queue.Any())
{
    var cur = queue.Dequeue();
    foreach (var next in cur.GetNeighbors())
    {
        if (IsOutsideMap(next) || IsOwnLine(next) || times.ContainsKey(next))
            continue;
        times.Add(next, times[cur] + bot.shiftTime);
        queue.Enqueue(next);
    }
}
```

Вот, раньше бот мог достичь любой клеточки, а теперь он не может пройти через
свой шлейф. Это проблема, потому что мы понимаем, что как только бот
достиг своей территории, он может идти куда угодно просто по прямой
(ну, то есть по манхеттенскому расстоянию).

Поэтому мы добавим в нашу карту
времени еще и точку, где бот впервые вернулся домой на свою территорию,
и дополнительно посчитаем время и по порвому алгоритму, от этой точки.
Пересечем две полученные карты и возьмем минимум - все, мы учли собственный
шлейф бота.

Следующее важное улучшение - учет бонусов.

Как учесть бонусы в первом подходе с движением по манхеттенскому 
расстоянию? Понятно, что подбор бонусов никак не учесть, потому что
мы никак не смотрим на состояние мира. Можно учесть только расход бонусов.
Нам известно сколько осталось действовать нитро и замедлялке, мы можем
разбить все расстояние на 4 части: 
- Сначала `min(nitroLeft, slowLeft)` - столько клеточек действуют оба
бонуса, следовательно скорость обычная, равная 5, и `shiftTime`, соответстсвенно,
равен 6.
- Затем `max(0, nitroLeft - slowLeft)` - столько клеточек действет только
нитро, следовательно скорость повышенная, равная 6, и `shiftTime`, соответственно,
равен 5.
- Затем `max(0, slowLeft - nitroLeft)` - столько клеточек действет только
замедлялка, следовательно скорость пониженная, равная 3, и `shiftTime`, соответственно,
равен 10.
- Оставшееся расстояние не действуют никакие бонусы, значит тоже все обычное.

Тонкий нюанс - если бот сейчас в пути, по по прибытии его бонусы уменьшатся
на единицу, надо не забыть это учесть.

Получилось следующее:
```c#
var times = new Dictionary<V, int>();
for (var x = 0; x < 31; ++x)
{
    for (var y = 0; y < 31; ++y)
    {
        var v = new V(x, y);
        var dist = (v - bot.arrivePos).ManhattanLength();

        var time = bot.arriveTime;

        var nitroLeft = bot.nitroLeft;
        var slowLeft = bot.slowLeft;
        if (bot.arriveTime > 0)
        {
            nitroLeft = Math.Max(0, nitroLeft - 1);
            slowLeft = Math.Max(0, slowLeft - 1);
        }

        var bothDist = Math.Min(dist, Math.Min(nitroLeft, slowLeft));
        time += bothDist * NORMAL_SHIFT_TIME;
        dist -= bothDist;
        
        var nitroDist = Math.Min(dist, Math.Max(0, nitroLeft - slowLeft));
        time += nitroDist * NITRO_SHIFT_TIME;
        dist -= nitroDist;
        
        var slowDist = Math.Min(dist, Math.Max(0, slowLeft - nitroLeft));
        time += slowDist * SLOW_SHIFT_TIME;
        dist -= slowDist;
        
        time += dist * NORMAL_SHIFT_TIME;

        times[v] = time;
    }
}
```

Ладно, теперь давайте придумаем, как учесть время во втором подходе,
с волной от `arrivePos` бота. Здесь мы уже бежим по миру и смотрим на его состояние.
Следовательно, сможем учесть подбор ботом бонусов.
Итак, тоже довольно простая идея. Будем строить вместе с картой времени также и карту,
на которой будем отмечать, сколько бонусов обоих типов осталось у бота. Если
бот приходит на клетку, и там лежит бонус, увенличиваем соответствующее число,
если нет, уменьшаем на единицу.

Дополнительный нюанс - теперь мы можем прийти в клеточку второй раз с лучшим временем,
чем приходили до этого. Как это учесть? Можно по разному. Самый, на мой взгляд,
простой способ - это использовать вместо очереди - очередь с приоритетом. В
качестве приоритета использовать время. Это будет уже не BFS, а алгоритм Дейкстры,
но кого это волнует? :) На самом деле в первом раунде, в песочнице, у меня была
обычная очередь, в которую могли попасть одни и те же клеточки и второй и в третий раз,
но потом я переделал на очередь с приоритетом, и все упростилось.

```c#
var times = new Dictionary<V, int>();
var nitroLefts = new Dictionary<V, int>();
var slowLefts = new Dictionary<V, int>();
var priorityQueue = new PriorityQueue<int, V>();

var nitroLeft = bot.nitroLeft;
var slowLeft = bot.slowLeft;
if (bot.arriveTime > 0)
{
    nitroLeft = Math.Max(0, nitroLeft - 1);
    slowLeft = Math.Max(0, slowLeft - 1);
}

var start = bot.arrivePos;

nitroLefts[start] = nitroLeft;
slowLefts[start] = slowLefts;
times[start] = bot.arriveTime;
priorityQueue.Enqueue(bot.arriveTime, start);

while(priorityQueue.Any())
{
    var (curTime, cur) = priorityQueue.Dequeue();
    var curNitroLeft = nitroLefts[cur];
    var curSlowLeft = slowLefts[cur];
    var curShiftTime = CalculateShiftTime(curNitroLeft, curSlowLeft);
    foreach (var next in cur.GetNeighbors())
    {
        if (IsOutsideMap(next) || IsOwnLine(next))
            continue;
        var nextTime = curTime + curShiftTime;
        if (times.TryGetValue(next, out var prevTime) && prevTime < nextTime)
            continue;
        var nextNitroLeft = Math.Max(0, curNitroLeft - 1);
        var nextSlowLeft = Math.Max(0, curSlowLeft - 1);
        if (map[next].Bonus is Nitro)
            nextNitroLeft += GetActiveTicks(map[next].Bonus);
        if (map[next].Bonus is Slow)
            nextSlowLeft += GetActiveTicks(map[next].Bonus);
        times[next] = nextTime;
        nitroLefts[next] = nextNitroLeft;
        slowLefts[next] = nextSlowLeft;
        queue.Enqueue(nextTime, next);
    }
}
```

Здесь есть две вспомогательные функции - `CalculateShiftTime` и `GetActiveTicks`.
Первая реализуется очевидно:

```c#
int CalculateShiftTime(nitroLeft, slowLeft)
{
    if (nitroLeft > 0 && slowLeft > 0)
        return NORMAL_SHIFT_TIME;
    if (nitroLeft > 0)
        return NITRO_SHIFT_TIME;
    if (slowLeft > 0
        return SLOW_SHIFT_TIME;
    return NORMAL_SHIFT_TIME;
}
```

Вторая предназначена для того, чтобы посчитать, на сколько клеточек действует
бонус. Из правил не было понятно, приходит ли эта информация в состоянии. И
в local-runner-е она приходила. Поэтому я учел оба варианта, и эта функция
просто берет значение из состояния мира, если оно там есть, и вычисляет, есмли его
там нет. Вычисляет так - если это нитро, то для моего бота бонус действует 
минимально возможное время - 10 клеточек, а для врагов - максимально возможное -
50 клеточек. Для замедлялки, соответственно, все наоботрот. Такие умолчания
позволяют надежнее учесть подбираемые бонусы и не ошибиться случайно.

```c#
int GetActiveTicks(Bonus bonus)
{
    if (bonus.ActiveTicks != null)
        return bonus.ActiveTicks;
    if (bonus is Nitro)
        return player == ME ? 10 : 50;
    if (bonus is Slow)
        return player == ME ? 50 : 10;
}
```

Описанный выше подход, совмещающий построение карты времени через очередь
и по манхеттенскому расстоянию я использовал в песочнице. Все дальнейшие улучшения
были сделаны на более поздних этапах.